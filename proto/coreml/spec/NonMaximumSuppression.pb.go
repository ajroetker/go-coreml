// Copyright (c) 2018, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.2
// source: NonMaximumSuppression.proto

package spec

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Non-maximum suppression of axis-aligned bounding boxes.
//
// This is used primarily for object detectors that tend to produce multiple
// boxes around a single object.  This is a byproduct of the detector's
// robustness to spatial translation. If there are two or more bounding boxes
// that are very similar to one another, the algorithm should return only a
// single representative.
//
// Similarity between two bounding boxes is measured by intersection-over-union
// (IOU), the fraction between the area of intersection and area of the union.
// Here is an example where the areas can be calculated by hand by counting glyphs::
//
//	+-------+                            +-------+
//	|       |                            |       |
//	|    +------+          +--+          |       +---+
//	|    |  |   |          |  |          |           |
//	+-------+   |          +--+          +----+      |
//	     |      |                             |      |
//	     +------+                             +------+
//	                   Intersection         Union
//	 IOU: 0.16      =       12       /       73
//
// All IOU scores are fractions between 0.0 (fully disjoint) and 1.0 (perfect
// overlap). The standard algorithm (PickTop) is defined as follows:
//
//  1. Sort boxes by descending order of confidence
//  2. Take the top one and mark it as keep
//  3. Suppress (mark it as discard) all boxes within a fixed IOU radius of the
//     keep box
//  4. Go to 2 and repeat on the subset of boxes not already kept or discarded
//  5. When all boxes are processed, output only the ones marked as keep
//
// Before the algorithm, boxes that fall below the confidence threshold are
// discarded.
type NonMaximumSuppression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Choose which underlying suppression method to use
	//
	// Types that are valid to be assigned to SuppressionMethod:
	//
	//	*NonMaximumSuppression_PickTop_
	SuppressionMethod isNonMaximumSuppression_SuppressionMethod `protobuf_oneof:"SuppressionMethod"`
	// Optional class label mapping.
	//
	// Types that are valid to be assigned to ClassLabels:
	//
	//	*NonMaximumSuppression_StringClassLabels
	//	*NonMaximumSuppression_Int64ClassLabels
	ClassLabels isNonMaximumSuppression_ClassLabels `protobuf_oneof:"ClassLabels"`
	// This defines the radius of suppression. A box is considered to be within
	// the radius of another box if their IOU score is less than this value.
	IouThreshold float64 `protobuf:"fixed64,110,opt,name=iouThreshold,proto3" json:"iouThreshold,omitempty"`
	// Remove bounding boxes below this threshold.  The algorithm run-time is
	// proportional to the square of the number of incoming bounding boxes
	// (O(N^2)). This threshold is a way to reduce N to make the algorithm
	// faster. The confidence threshold can be any non-negative value. Negative
	// confidences are not allowed, since if the output shape is specified to be
	// larger than boxes after suppression, the unused boxes are filled with
	// zero confidence. If the prediction is handled by Core Vision, it is also
	// important that confidences are defined with the following semantics:
	//
	//  1. Confidences should be between 0 and 1
	//  2. The sum of the confidences for a prediction should not exceed 1, but is
	//     allowed to be less than 1
	//  3. The sum of the confidences will be interpreted as the confidence of
	//     any object (e.g. if the confidences for two classes are 0.2 and 0.4,
	//
	// it means there is a 60% (0.2 + 0.4) confidence that an object is
	// present)
	ConfidenceThreshold float64 `protobuf:"fixed64,111,opt,name=confidenceThreshold,proto3" json:"confidenceThreshold,omitempty"`
	// Set the name of the confidence input.
	//
	// The input should be a multi-array of type double and shape N x C. N is
	// the number of boxes and C the number of classes. Each row describes the
	// confidences of each object category being present at that particular
	// location. Confidences should be nonnegative, where 0.0 means the highest
	// certainty the object is not present.
	//
	// Specifying shape is optional.
	ConfidenceInputFeatureName string `protobuf:"bytes,200,opt,name=confidenceInputFeatureName,proto3" json:"confidenceInputFeatureName,omitempty"`
	// Set the name of the coordinates input.
	//
	// The input should be a multi-array of type double and shape N x 4. The
	// rows correspond to the rows of the confidence matrix. The four values
	// describe (in order):
	//
	//   - x (center location of the box along the horizontal axis)
	//   - y (center location of the box along the vertical axis)
	//   - width (size of box along the horizontal axis)
	//   - height (size of box on along the vertical axis)
	//
	// Specifying shape is optional.
	CoordinatesInputFeatureName string `protobuf:"bytes,201,opt,name=coordinatesInputFeatureName,proto3" json:"coordinatesInputFeatureName,omitempty"`
	// The iouThreshold can be optionally overridden by specifying this string
	// and providing a corresponding input of type double. This allows changing
	// the value of the parameter during run-time.
	//
	// The input should be a scalar double between 0.0 and 1.0. Setting it to 1.0
	// means there will be no suppression based on IOU.
	IouThresholdInputFeatureName string `protobuf:"bytes,202,opt,name=iouThresholdInputFeatureName,proto3" json:"iouThresholdInputFeatureName,omitempty"`
	// The confidenceThreshold can be optionally overridden by specifying this
	// string and providing a corresponding input. This allows changing the
	// value of the parameter during run-time, which can aid setting it just
	// right for a particular use case.
	//
	// The input should be a scalar double with nonnegative value.
	ConfidenceThresholdInputFeatureName string `protobuf:"bytes,203,opt,name=confidenceThresholdInputFeatureName,proto3" json:"confidenceThresholdInputFeatureName,omitempty"`
	// Set the name of the confidence output. The output will be the same type
	// and shape as the corresponding input. The only difference is that the
	// number of rows may have been reduced.
	//
	// Specifying shape is optional. One reason to specify shape is to limit
	// the number of output boxes. This can be done is several ways:
	//
	// Fixed shape:
	// The output can be pinned to a fixed set of boxes. If this number is larger
	// than the number of boxes that would have been returned, the output is padded
	// with zeros for both confidence and coordinates. Specifying a fixed shape
	// can be done by setting either shape (deprecated) or allowedShapes set to
	// fixedsize.
	//
	// Min/max:
	// It is also possible to set both a minimum and a maximum. The same zero-padding
	// as for fixed shape is applied when necessary. Setting min/max is done by defining
	// two allowedShapes, where the first dimension uses a rangeofsizes defining lowerbound
	// and upperbound.
	ConfidenceOutputFeatureName string `protobuf:"bytes,210,opt,name=confidenceOutputFeatureName,proto3" json:"confidenceOutputFeatureName,omitempty"`
	// Set the name of the coordinates output. The output will be the same type
	// and shape as the corresponding input. The only difference is that the
	// number of rows may have been reduced.
	//
	// Specifying shape is optional. See confidence output for a more detailed
	// description. Note that to achieve either fixed shape output or a
	// constraint range of boxes, only one of confidence or coordinates need to
	// set a shape. Both shapes are allowed to be defined, but in such case they
	// have to be consistent along dimension 0.
	CoordinatesOutputFeatureName string `protobuf:"bytes,211,opt,name=coordinatesOutputFeatureName,proto3" json:"coordinatesOutputFeatureName,omitempty"`
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *NonMaximumSuppression) Reset() {
	*x = NonMaximumSuppression{}
	mi := &file_NonMaximumSuppression_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NonMaximumSuppression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NonMaximumSuppression) ProtoMessage() {}

func (x *NonMaximumSuppression) ProtoReflect() protoreflect.Message {
	mi := &file_NonMaximumSuppression_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NonMaximumSuppression.ProtoReflect.Descriptor instead.
func (*NonMaximumSuppression) Descriptor() ([]byte, []int) {
	return file_NonMaximumSuppression_proto_rawDescGZIP(), []int{0}
}

func (x *NonMaximumSuppression) GetSuppressionMethod() isNonMaximumSuppression_SuppressionMethod {
	if x != nil {
		return x.SuppressionMethod
	}
	return nil
}

func (x *NonMaximumSuppression) GetPickTop() *NonMaximumSuppression_PickTop {
	if x != nil {
		if x, ok := x.SuppressionMethod.(*NonMaximumSuppression_PickTop_); ok {
			return x.PickTop
		}
	}
	return nil
}

func (x *NonMaximumSuppression) GetClassLabels() isNonMaximumSuppression_ClassLabels {
	if x != nil {
		return x.ClassLabels
	}
	return nil
}

func (x *NonMaximumSuppression) GetStringClassLabels() *StringVector {
	if x != nil {
		if x, ok := x.ClassLabels.(*NonMaximumSuppression_StringClassLabels); ok {
			return x.StringClassLabels
		}
	}
	return nil
}

func (x *NonMaximumSuppression) GetInt64ClassLabels() *Int64Vector {
	if x != nil {
		if x, ok := x.ClassLabels.(*NonMaximumSuppression_Int64ClassLabels); ok {
			return x.Int64ClassLabels
		}
	}
	return nil
}

func (x *NonMaximumSuppression) GetIouThreshold() float64 {
	if x != nil {
		return x.IouThreshold
	}
	return 0
}

func (x *NonMaximumSuppression) GetConfidenceThreshold() float64 {
	if x != nil {
		return x.ConfidenceThreshold
	}
	return 0
}

func (x *NonMaximumSuppression) GetConfidenceInputFeatureName() string {
	if x != nil {
		return x.ConfidenceInputFeatureName
	}
	return ""
}

func (x *NonMaximumSuppression) GetCoordinatesInputFeatureName() string {
	if x != nil {
		return x.CoordinatesInputFeatureName
	}
	return ""
}

func (x *NonMaximumSuppression) GetIouThresholdInputFeatureName() string {
	if x != nil {
		return x.IouThresholdInputFeatureName
	}
	return ""
}

func (x *NonMaximumSuppression) GetConfidenceThresholdInputFeatureName() string {
	if x != nil {
		return x.ConfidenceThresholdInputFeatureName
	}
	return ""
}

func (x *NonMaximumSuppression) GetConfidenceOutputFeatureName() string {
	if x != nil {
		return x.ConfidenceOutputFeatureName
	}
	return ""
}

func (x *NonMaximumSuppression) GetCoordinatesOutputFeatureName() string {
	if x != nil {
		return x.CoordinatesOutputFeatureName
	}
	return ""
}

type isNonMaximumSuppression_SuppressionMethod interface {
	isNonMaximumSuppression_SuppressionMethod()
}

type NonMaximumSuppression_PickTop_ struct {
	PickTop *NonMaximumSuppression_PickTop `protobuf:"bytes,1,opt,name=pickTop,proto3,oneof"`
}

func (*NonMaximumSuppression_PickTop_) isNonMaximumSuppression_SuppressionMethod() {}

type isNonMaximumSuppression_ClassLabels interface {
	isNonMaximumSuppression_ClassLabels()
}

type NonMaximumSuppression_StringClassLabels struct {
	StringClassLabels *StringVector `protobuf:"bytes,100,opt,name=stringClassLabels,proto3,oneof"`
}

type NonMaximumSuppression_Int64ClassLabels struct {
	Int64ClassLabels *Int64Vector `protobuf:"bytes,101,opt,name=int64ClassLabels,proto3,oneof"`
}

func (*NonMaximumSuppression_StringClassLabels) isNonMaximumSuppression_ClassLabels() {}

func (*NonMaximumSuppression_Int64ClassLabels) isNonMaximumSuppression_ClassLabels() {}

// Pick the bounding box of the top confidence, suppress all within a radius.
type NonMaximumSuppression_PickTop struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Suppression is only done among predictions with the same label
	// (argmax of the confidence).
	PerClass      bool `protobuf:"varint,1,opt,name=perClass,proto3" json:"perClass,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NonMaximumSuppression_PickTop) Reset() {
	*x = NonMaximumSuppression_PickTop{}
	mi := &file_NonMaximumSuppression_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NonMaximumSuppression_PickTop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NonMaximumSuppression_PickTop) ProtoMessage() {}

func (x *NonMaximumSuppression_PickTop) ProtoReflect() protoreflect.Message {
	mi := &file_NonMaximumSuppression_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NonMaximumSuppression_PickTop.ProtoReflect.Descriptor instead.
func (*NonMaximumSuppression_PickTop) Descriptor() ([]byte, []int) {
	return file_NonMaximumSuppression_proto_rawDescGZIP(), []int{0, 0}
}

func (x *NonMaximumSuppression_PickTop) GetPerClass() bool {
	if x != nil {
		return x.PerClass
	}
	return false
}

var File_NonMaximumSuppression_proto protoreflect.FileDescriptor

const file_NonMaximumSuppression_proto_rawDesc = "" +
	"\n" +
	"\x1bNonMaximumSuppression.proto\x12\x14CoreML.Specification\x1a\x14DataStructures.proto\"\xd2\x06\n" +
	"\x15NonMaximumSuppression\x12O\n" +
	"\apickTop\x18\x01 \x01(\v23.CoreML.Specification.NonMaximumSuppression.PickTopH\x00R\apickTop\x12R\n" +
	"\x11stringClassLabels\x18d \x01(\v2\".CoreML.Specification.StringVectorH\x01R\x11stringClassLabels\x12O\n" +
	"\x10int64ClassLabels\x18e \x01(\v2!.CoreML.Specification.Int64VectorH\x01R\x10int64ClassLabels\x12\"\n" +
	"\fiouThreshold\x18n \x01(\x01R\fiouThreshold\x120\n" +
	"\x13confidenceThreshold\x18o \x01(\x01R\x13confidenceThreshold\x12?\n" +
	"\x1aconfidenceInputFeatureName\x18\xc8\x01 \x01(\tR\x1aconfidenceInputFeatureName\x12A\n" +
	"\x1bcoordinatesInputFeatureName\x18\xc9\x01 \x01(\tR\x1bcoordinatesInputFeatureName\x12C\n" +
	"\x1ciouThresholdInputFeatureName\x18\xca\x01 \x01(\tR\x1ciouThresholdInputFeatureName\x12Q\n" +
	"#confidenceThresholdInputFeatureName\x18\xcb\x01 \x01(\tR#confidenceThresholdInputFeatureName\x12A\n" +
	"\x1bconfidenceOutputFeatureName\x18\xd2\x01 \x01(\tR\x1bconfidenceOutputFeatureName\x12C\n" +
	"\x1ccoordinatesOutputFeatureName\x18\xd3\x01 \x01(\tR\x1ccoordinatesOutputFeatureName\x1a%\n" +
	"\aPickTop\x12\x1a\n" +
	"\bperClass\x18\x01 \x01(\bR\bperClassB\x13\n" +
	"\x11SuppressionMethodB\r\n" +
	"\vClassLabelsB0H\x03Z,github.com/gomlx/go-coreml/proto/coreml/specP\x00b\x06proto3"

var (
	file_NonMaximumSuppression_proto_rawDescOnce sync.Once
	file_NonMaximumSuppression_proto_rawDescData []byte
)

func file_NonMaximumSuppression_proto_rawDescGZIP() []byte {
	file_NonMaximumSuppression_proto_rawDescOnce.Do(func() {
		file_NonMaximumSuppression_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_NonMaximumSuppression_proto_rawDesc), len(file_NonMaximumSuppression_proto_rawDesc)))
	})
	return file_NonMaximumSuppression_proto_rawDescData
}

var file_NonMaximumSuppression_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_NonMaximumSuppression_proto_goTypes = []any{
	(*NonMaximumSuppression)(nil),         // 0: CoreML.Specification.NonMaximumSuppression
	(*NonMaximumSuppression_PickTop)(nil), // 1: CoreML.Specification.NonMaximumSuppression.PickTop
	(*StringVector)(nil),                  // 2: CoreML.Specification.StringVector
	(*Int64Vector)(nil),                   // 3: CoreML.Specification.Int64Vector
}
var file_NonMaximumSuppression_proto_depIdxs = []int32{
	1, // 0: CoreML.Specification.NonMaximumSuppression.pickTop:type_name -> CoreML.Specification.NonMaximumSuppression.PickTop
	2, // 1: CoreML.Specification.NonMaximumSuppression.stringClassLabels:type_name -> CoreML.Specification.StringVector
	3, // 2: CoreML.Specification.NonMaximumSuppression.int64ClassLabels:type_name -> CoreML.Specification.Int64Vector
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_NonMaximumSuppression_proto_init() }
func file_NonMaximumSuppression_proto_init() {
	if File_NonMaximumSuppression_proto != nil {
		return
	}
	file_DataStructures_proto_init()
	file_NonMaximumSuppression_proto_msgTypes[0].OneofWrappers = []any{
		(*NonMaximumSuppression_PickTop_)(nil),
		(*NonMaximumSuppression_StringClassLabels)(nil),
		(*NonMaximumSuppression_Int64ClassLabels)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_NonMaximumSuppression_proto_rawDesc), len(file_NonMaximumSuppression_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_NonMaximumSuppression_proto_goTypes,
		DependencyIndexes: file_NonMaximumSuppression_proto_depIdxs,
		MessageInfos:      file_NonMaximumSuppression_proto_msgTypes,
	}.Build()
	File_NonMaximumSuppression_proto = out.File
	file_NonMaximumSuppression_proto_goTypes = nil
	file_NonMaximumSuppression_proto_depIdxs = nil
}
